using Dapper.Entities.Exceptions;
using Dapper.Entities.Interfaces;
using Microsoft.Extensions.Logging;
using System.Data;
using System.Reflection;

namespace Dapper.Entities;

public enum RepositoryAction
{
	Insert,
	Update,
	Delete,
	Get
}

public class Repository<TDatabase, TEntity, TKey>
	where TDatabase : Database
	where TEntity : IEntity<TKey>
	where TKey : notnull
{
	private readonly SqlStatements _sqlStatements;

	protected readonly TDatabase Database;

	public Repository(TDatabase database)
	{
		Database = database;
		_sqlStatements = Database.SqlBuilder.BuildStatements(typeof(TEntity));
	}

	protected virtual CommandType GetCommandType => CommandType.Text;
	protected virtual CommandType InsertCommandType => CommandType.Text;
	protected virtual CommandType UpdateCommandType => CommandType.Text;
	protected virtual CommandType DeleteCommandType => CommandType.Text;

	protected virtual string? CustomGetCommand { get; }
	protected virtual string? CustomInsertCommand { get; }
	protected virtual string? CustomUpdateCommand { get; }
	protected virtual string? CustomDeleteCommand { get; }

	public async Task<TEntity?> GetOptionalAsync(IDbConnection connection, TKey id, IDbTransaction? transaction = null)
	{
		var sql = CustomGetCommand ?? _sqlStatements.GetById;
		return await GetInnerAsync(connection, sql, new { id }, transaction);
	}

	public async Task<TEntity?> GetOptionalAsync(TKey id)
	{
		using var cn = Database.GetConnection();
		return await GetOptionalAsync(cn, id);
	}

	public async Task<TEntity?> GetAlternateAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction = null)
	{
		if (!_sqlStatements.HasAlternateKey)
		{
			throw new NotImplementedException($"Entity type {typeof(TEntity).Name} must have at least one updateable column with the [Key] attribute to use with the MergeAsync method");
		}

		return await GetInnerAsync(connection, _sqlStatements.GetByAlternateKey, entity, transaction, "GetAlternate");
	}

	public async Task<TEntity?> GetAlternateAsync(TEntity entity)
	{
		using var cn = Database.GetConnection();
		return await GetAlternateAsync(cn, entity);
	}

	public async Task<TEntity> GetAsync(IDbConnection connection, TKey id, IDbTransaction? transaction = null) =>
		await GetOptionalAsync(connection, id, transaction) ?? throw new Exception($"{typeof(TEntity).Name} row id {id} not found");

	public async Task<TEntity> GetAsync(TKey id) =>
		await GetOptionalAsync(id) ?? throw new Exception($"{typeof(TEntity).Name} row id {id} not found");

	protected async Task<TEntity?> GetInnerAsync(IDbConnection connection, string sql, object parameter, IDbTransaction? transaction = null, string action = "Get")
	{
		Database.Logger.LogTrace("{action}: {query}, Id = {id}", action, sql, parameter);

		TEntity? result;

		try
		{
			result = await connection.QuerySingleOrDefaultAsync<TEntity>(sql, parameter, transaction, commandType: GetCommandType);
		}
		catch (Exception exc)
		{
			Database.Logger.LogError(exc, "Error executing query: {sql} with params {@parameter}", sql, parameter);
			throw new RepositoryException(RepositoryAction.Get, exc.Message);
		}

		if (result is not null)
		{
			var (allow, message) = await AllowGetAsync(connection, result, transaction);
			if (!allow) throw new RepositoryException(RepositoryAction.Get, message!);

			await AfterGetAsync(connection, result, transaction);
		}

		return result;
	}

	private async Task<TEntity> SaveInternalAsync(IDbConnection connection, TEntity entity, PropertyInfo[]? properties = null, Dictionary<string, object?>? originalValues = null, IDbTransaction? transaction = null)
	{
		ArgumentNullException.ThrowIfNull(nameof(entity));

		var action = entity.IsNew() ? RepositoryAction.Insert : RepositoryAction.Update;

		var (allow, message) = await AllowSaveAsync(connection, action, entity, transaction);
		if (!allow) throw new RepositoryException(action, message!);

		var commandType = (action is RepositoryAction.Insert) ? InsertCommandType : UpdateCommandType;

		await BeforeSaveAsync(connection, action, entity, transaction);

		var modifiedProperties = ModifiedProperties(entity, properties ?? [], originalValues ?? []);

		var sql =
			(action is RepositoryAction.Insert) ? CustomInsertCommand ?? _sqlStatements.Insert :
			(action is RepositoryAction.Update && modifiedProperties.Any()) ? _sqlStatements.UpdateColumns(modifiedProperties) :
			CustomUpdateCommand ?? _sqlStatements.Update;

		Database.Logger.LogTrace("{entityType}.{action}: {query}, {@entity}", typeof(TEntity).Name, action, sql, entity);

		try
		{
			var id = await connection.ExecuteScalarAsync<TKey>(sql, entity, transaction, commandType: commandType);
			if (action is RepositoryAction.Insert) entity.Id = id ?? throw new Exception("No key generated by INSERT");
		}
		catch (Exception exc)
		{
			Database.Logger.LogError(exc, "Error executing query: {sql} with params {@entity}", sql, entity);
			throw new RepositoryException(action, exc.Message, exc) { Sql = sql, Parameters = entity };
		}

		await AfterSaveAsync(connection, action, entity, transaction);

		return entity;

	}

	public async Task<TEntity> SaveAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction = null) =>
		await SaveInternalAsync(connection, entity, transaction: transaction);

	public async Task<TEntity> SaveAsync(TEntity entity)
	{
		using var cn = Database.GetConnection();
		return await SaveAsync(cn, entity);
	}

	public async Task<TEntity> MergeAsync(IDbConnection connection, TEntity entity, Action<TEntity, TEntity>? onExisting = null, IDbTransaction? transaction = null)
	{
		if (entity.IsNew())
		{
			var existing = await GetAlternateAsync(connection, entity, transaction);
			if (existing is not null)
			{
				onExisting?.Invoke(entity, existing);
				entity.Id = existing.Id;
			}
		}

		return await SaveAsync(entity);
	}

	public async Task<TEntity> MergeAsync(TEntity entity, Action<TEntity, TEntity>? onExisting = null)
	{
		using var cn = Database.GetConnection();
		return await MergeAsync(cn, entity, onExisting);
	}

	public async Task DeleteAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction = null)
	{
		ArgumentNullException.ThrowIfNull(nameof(entity));

		var (allow, message) = await AllowDeleteAsync(connection, entity, transaction);
		if (!allow) throw new RepositoryException(RepositoryAction.Delete, message!);

		await BeforeDeleteAsync(connection, entity, transaction);

		var sql = CustomDeleteCommand ?? _sqlStatements.Delete;
		Database.Logger.LogTrace("{entityType}.{action}: {query}, {@entity}", typeof(TEntity).Name, RepositoryAction.Delete, sql, entity);

		var param = new { id = entity.Id };

		try
		{
			await connection.ExecuteAsync(sql, param, transaction, commandType: DeleteCommandType);
		}
		catch (Exception exc)
		{
			Database.Logger.LogError(exc, "Error executing query: {sql} with params {@param}", sql, param);
			throw new RepositoryException(RepositoryAction.Delete, exc.Message, exc) { Sql = sql, Parameters = param };
		}

		await AfterDeleteAsync(connection, entity, transaction);
	}

	public async Task DeleteAsync(TEntity entity)
	{
		using var cn = Database.GetConnection();
		await DeleteAsync(cn, entity);
	}

	public async Task UpdateAsync(TKey id, Action<TEntity> setProperties)
	{
		using var cn = Database.GetConnection();
		await UpdateAsync(cn, id, setProperties);
	}

	public async Task UpdateAsync(IDbConnection connection, TKey id, Action<TEntity> setProperties, IDbTransaction? transaction = null)
	{
		TEntity row = await GetAsync(connection, id, transaction);

		var (properties, rowValues) = GetRowValuesDictionary(row);
		
		setProperties(row);		

		await SaveInternalAsync(connection, row, properties, rowValues, transaction);
	}

	private static (PropertyInfo[] Properties, Dictionary<string, object?> RowValues) GetRowValuesDictionary<T>(T entity)
	{
		Dictionary<string, object?> result = [];

		var properties = typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance);
		foreach (var propertyInfo in properties) result.Add(propertyInfo.Name, propertyInfo.GetValue(entity));

		return (properties, result);
	}

	private static string[] ModifiedProperties<T>(T entity, PropertyInfo[] properties, Dictionary<string, object?> originalValues)
	{
		if (!properties.Any()) return [];

		var modifiedProperties = new List<string>();
		
		foreach (var propertyInfo in properties)
		{
			var originalValue = originalValues[propertyInfo.Name];
			var currentValue = propertyInfo.GetValue(entity);

			if (!Equals(originalValue, currentValue))
			{
				modifiedProperties.Add(propertyInfo.Name);
			}
		}

		return [.. modifiedProperties];
	}

	protected virtual async Task AfterGetAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction) => await Task.CompletedTask;

	protected virtual async Task<(bool Result, string? Message)> AllowGetAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction) => await Task.FromResult((true, default(string)));

	protected virtual async Task<(bool Result, string? Message)> AllowSaveAsync(IDbConnection connection, RepositoryAction action, TEntity entity, IDbTransaction? transaction) => await Task.FromResult((true, default(string)));

	protected virtual async Task BeforeSaveAsync(IDbConnection connection, RepositoryAction action, TEntity entity, IDbTransaction? transaction) => await Task.CompletedTask;

	protected virtual async Task AfterSaveAsync(IDbConnection connection, RepositoryAction action, TEntity entity, IDbTransaction? transaction) => await Task.CompletedTask;

	protected virtual async Task<(bool Result, string? Message)> AllowDeleteAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction) => await Task.FromResult((true, default(string)));

	protected virtual async Task BeforeDeleteAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction) => await Task.CompletedTask;

	protected virtual async Task AfterDeleteAsync(IDbConnection connection, TEntity entity, IDbTransaction? transaction) => await Task.CompletedTask;
}
